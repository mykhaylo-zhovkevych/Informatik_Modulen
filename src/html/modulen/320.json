{
    "title": "M320",
    "mainTitle": "M320 => Objektorientiert Programmieren",
    "cards": [
        { "title": "Thems", "value": 5 },
        { "title": "Sections", "value": 11 },
        { "title": "Codes", "value": 20 }
    ],
    "charts": [
        {
            "type": "verzeichnis",
            "title": "Verzeichnis",
            "items": [
                { "label": "1. Einleitung", "id": "section1" },
                { "label": "2. Grundlagen", "id": "section2" },
                { "label": "3. Block01", "id": "section3" },
                { "label": "4. Block02", "id": "section4" },
                { "label": "5. Block03", "id": "section5" },
                { "label": "6. Block04", "id": "section6" },
                { "label": "7. Block05", "id": "section7" },
                { "label": "8. Block06", "id": "section8" },
                { "label": "9. Block07/08", "id": "section9" },
                { "label": "10. Block09", "id": "section10" },

                { "label": "16. Aufgabe01", "id": "section16" },
                { "label": "17. Aufgabe02", "id": "section17" },
                { "label": "18. Aufgabe03", "id": "section18" },
                { "label": "19. Aufgabe04", "id": "section19" },

                { "label": "12. Projekt Teil01", "id": "section12" },
                { "label": "13. Projekt Teil02", "id": "section13" },
                { "label": "14. Projekt Teil03", "id": "section14" },
                { "label": "15. Projekt Teil04", "id": "section15" },
                
                { "label": "20. Abschlussauswertung", "id": "section20" }
            ]
        }
    ],
    "mainTextContent": [
        {
            "type": "text",
            "content": "Einleitung",
            "id": "section1",
            "subContent": [
                {
                    "type": "HandlungsZiele",
                    "ziel": "Kompetenz: Applikationen und Schnittstellen objektorientiert modellieren, implementieren, testen und dokumentieren. Objekt: Anwendung mit 3 bis 5 fachlichen Klassen.",
                    "HandlungsnotwendigeKenntnisse": [
                        "Kennt den objektorientierten Ansatz mit den Grundkonzepten Kapselung, Vererbung und Polymorphie.",
                        "Kennt Vorgehensprinzipien zur Klassenfindung (z.B. Spezialisierung und Generalisierung, Domänenmodell und –Events, BoundedContext, DRY, SRP).",
                        "Kennt Abstraktionskonzepte wie Assoziationen, Klassen, Attribute und Methoden, Schnittstellen und abstrakte Klassen und Datentypen (ADT, Collections, Generics).",
                        "Kennt Beschreibungen (z.B. CRC-Card) und Diagrammnotationen (z.B. UML, TAM, 4+1) für statische und dynamische Aspekte von objektorientiertem Design.",
                        "Kennt das Dokumentieren mit einer Dokumentationsinfrastruktur (z.B. Javadoc).",
                        "Kennt den Unterschied zwischen Klassen und Objekten. Kennt eine objektorientierte Sprache und deren Elemente und kann damit das Design umsetzen.",
                        "Kennt das Konzept der dynamischen Bindung. Kennt das Konzept der Inversion of Control (DependencyInjection)",
                        "Kennt Verfahren zum Erstellen von Testfällen. Kennt Testmethoden zur Überprüfung der Komponenten einer Anwendung (automatisches Unit-Testing)."
                    ]
                },
                {
                    "type": "image",
                    "src": "/imgs/gettyimages-1146649674-1024x1024.webp",
                    "alt": "Descriptive Alt Text",
                    "id": "section6"
                }
            ]
        },
        {
            "type": "text",
            "content": "Grundlagen",
            "id": "section2",
            "subContent": [
                {
                    "_comment": "Start of OOP",
                    "type": "sub-text",
                    "content": "Definition => Objektorientiertes Denken: Beim objektorientierten Denken geht es darum, Probleme und Lösungen in Form von Objekten zu modellieren. Man stellt sich vor, wie die verschiedenen Objekte interagieren und zusammenarbeiten, um das gewünschte Verhalten des Systems zu erreichen. Dabei werden die Prinzipien der Kapselung, Vererbung und Polymorphismus genutzt, um ein flexibles, erweiterbares und wartbares System zu entwickeln."
                },
                {
                    "_comment": "What is Object",
                    "type": "sub-text",
                    "content": "Definition => Ein Objekt ist eine Instanz einer Klasse. Wenn eine Klasse wie eine Schablone ist, dann ist ein Objekt ein konkretes Exemplar, das nach dieser Schablone erstellt wurde. Jedes Objekt hat seinen eigenen Zustand, der durch die Attribute der Klasse definiert wird."
                },
                {
                    "_comment": "What is Class",
                    "type": "sub-text",
                    "content": "Definition => Eine Klasse ist ein Bauplan oder eine Vorlage für Objekte. Sie definiert, welche Attribute und Methoden die Objekte dieser Klasse haben werden. Man kann sich eine Klasse wie eine Schablone vorstellen."
                },
                {
                    "_comment": "What is Attribute",
                    "type": "sub-text",
                    "content": "Definition => Attribute sind Variablen, die den Zustand eines Objekts beschreiben. Zum Beispiel könnte ein Auto-Objekt Attribute wie Farbe, Marke und Geschwindigkeit haben."
                },
                {
                    "_comment": "What is Methods",
                    "type": "sub-text",
                    "content": " Definition => Methoden in der OOP sind Funktionen, die innerhalb einer Klasse definiert sind und das Verhalten der Objekte dieser Klasse beschreiben. Zweck => Sie ermöglichen es Objekten, Aktionen auszuführen und auf ihre eigenen Daten zuzugreifen oder diese zu verändern."
                },
                {
                    "type": "sub-layout",
                    "subContent": [
                        {
                            "type": "sub-text",
                            "content": "Definition => Instanzmethoden sind Methoden, die auf einer Instanz einer Klasse arbeiten. Diese Methoden können auf die Attribute (Instanzvariablen) des Objekts zugreifen und diese verändern. Sie werden über ein Objekt der Klasse aufgerufen. Zweck => Instanzmethoden werden verwendet, um Verhalten zu definieren, das spezifisch für einzelne Objekte ist. Sie ermöglichen es den Objekten, Aktionen auszuführen und auf ihren Zustand zu reagieren."
                        },
                        {
                            "type": "sub-text",
                            "content": "Definition => Klassenmethoden sind Methoden, die auf der Klasse selbst und nicht auf Instanzen der Klasse arbeiten. Sie werden in Java mit dem Schlüsselwort static deklariert. Zweck => Klassenmethoden werden verwendet, um Verhalten zu definieren, das sich auf die Klasse als Ganzes bezieht, anstatt auf einzelne Instanzen. Sie sind nützlich für: Utility- oder Hilfsfunktionen, die allgemeine Operationen durchführen, die nicht von einer bestimmten Instanz abhängen. Und Zugriff auf Klassenvariablen: Sie können auf statische Variablen der Klasse zugreifen und diese manipulieren, da diese ebenfalls zur Klasse und nicht zu einer Instanz gehören."
                        },
                        {
                            "type": "sub-text",
                            "content": "Definition => Statische Methoden sind eine spezielle Art von Klassenmethoden, die unabhängig von Instanzen der Klasse sind. Sie benötigen keine Referenz auf ein Objekt der Klasse und können direkt über die Klasse aufgerufen werden. Zweck => Statische Methoden sind besonders nützlich für: Allgemeine Utility-Funktionen: Funktionen, die keine Informationen über den Zustand einer bestimmten Instanz benötigen und somit unabhängig von Instanzvariablen sind. Und  Kapselung von Funktionen: Sie bieten eine Möglichkeit, allgemeine Funktionen innerhalb der Klasse zu kapseln, die weder Instanzvariablen noch Methoden benötigen."
                        }
                    ]
                },
                {
                    "type": "sub-container-code",
                    "_comment": "Instanzmethoden Code",
                    "content": [
                        "// Instanzmethoden",
                        "class Auto {",
                        "    private String farbe;",
                        "    private String marke;",
                        "",
                        "    public Auto(String farbe, String marke) {",
                        "        this.farbe = farbe;",
                        "        this.marke = marke;",
                        "    }",
                        "",
                        "    public void fahren(int geschwindigkeit) {",
                        "        System.out.println(\"Das \" + this.marke + \" Auto fährt mit \" + geschwindigkeit + \" km/h.\");",
                        "    }",
                        "}",
                        "",
                        "public class Main {",
                        "    public static void main(String[] args) {",
                        "        Auto meinAuto = new Auto(\"Rot\", \"BMW\");",
                        "        meinAuto.fahren(100);  // Ausgabe: Das BMW Auto fährt mit 100 km/h.",
                        "    }",
                        "}"
                    ]
                },
                {
                    "type": "sub-container-code",
                    "_comment": "Klassenmethoden Code",
                    "content": [
                        "// Klassenmethoden",
                        "class Auto {",
                        "    private String farbe;",
                        "    private String marke;",
                        "    private static int anzahlAutos = 0;",
                        "",
                        "    public Auto(String farbe, String marke) {",
                        "        this.farbe = farbe;",
                        "        this.marke = marke;",
                        "        anzahlAutos++;",
                        "    }",
                        "",
                        "    public static void zeigeAnzahlAutos() {",
                        "        System.out.println(\"Es gibt \" + anzahlAutos + \" Autos.\");",
                        "    }",
                        "}",
                        "",
                        "public class Main {",
                        "    public static void main(String[] args) {",
                        "        Auto auto1 = new Auto(\"Rot\", \"BMW\");",
                        "        Auto auto2 = new Auto(\"Blau\", \"Audi\");",
                        "        Auto.zeigeAnzahlAutos();  // Ausgabe: Es gibt 2 Autos.",
                        "    }",
                        "}"
                    ]
                },
                {
                    "type": "sub-container-code",
                    "_comment": "Statische Methoden Code",
                    "content": [
                        "// Statische Methoden",
                        "class MathUtils {",
                        "    public static int addiere(int a, int b) {",
                        "        return a + b;",
                        "    }",
                        "}",
                        "",
                        "public class Main {",
                        "    public static void main(String[] args) {",
                        "        int summe = MathUtils.addiere(5, 3);",
                        "        System.out.println(\"Die Summe ist: \" + summe);  // Ausgabe: Die Summe ist: 8",
                        "    }",
                        "}"
                    ]
                },
                {
                    "type": "sub-text",
                    "content": "Unterschiede zwischen Klassenmethoden und statischen Methodenm => In Java gibt es keinen funktionalen Unterschied zwischen Klassenmethoden und statischen Methoden, da beide mit dem Schlüsselwort static deklariert werden und auf dieselbe Weise verwendet werden. Der Begriff 'statische Methode' wird oft synonym mit 'Klassenmethode' verwendet. Der Unterschied liegt mehr in der Perspektive und dem Kontext der Nutzung: Klassenmethoden: Der Fokus liegt darauf, dass diese Methoden zur Klasse gehören und Klassenvariablen verwenden können. Sie sind Teil des Verhaltens der Klasse als Ganzes. Statische Methoden: Der Fokus liegt darauf, dass diese Methoden unabhängig von Instanzen sind. Sie kapseln allgemeine Funktionen, die keinen Zugriff auf Instanzvariablen oder Instanzmethoden benötigen."
                    
                },
                {
                    "type": "sub-layout",
                    "subContent": [
                        {
                            "_comment": "Method Overloading",
                            "type": "sub-text",
                            "content": "Definition => Method Overloading bedeutet, dass mehrere Methoden in einer Klasse denselben Namen haben, sich aber in der Anzahl oder den Typen der Parameter unterscheiden. Es ermöglicht es, ähnliche Methoden mit unterschiedlichen Signaturen zu definieren. Zweck => Method Overloading wird verwendet, um Methoden zu definieren, die ähnliche Operationen ausführen, aber unterschiedliche Parameter akzeptieren. Es verbessert die Lesbarkeit und Wartbarkeit des Codes, indem es die Methode für verschiedene Eingabetypen anpasst."
                        },
                        {
                            "_comment": "Method Overriding",
                            "type": "sub-text",
                            "content": "Definition => Method Overriding bedeutet, dass eine Methode in einer Subklasse die gleiche Signatur wie eine Methode in der Superklasse hat und deren Verhalten überschreibt. Es ermöglicht es, die spezifische Implementierung einer Methode in einer abgeleiteten Klasse anzupassen. Zweck => Method Overriding wird verwendet, um das Verhalten einer geerbten Methode in einer Subklasse zu ändern oder zu erweitern. Es ermöglicht die Nutzung von Polymorphismus und stellt sicher, dass eine Methode in der Subklasse eine spezifische Implementierung hat."
                        }
                    ]
                },
                {
                    "type": "sub-container-code",
                    "_comment": "Method Overloading ",
                    "content": [
                        "// Method Overloading",
                        "class Rechner {",
                        "    public int addiere(int a, int b) {",
                        "        return a + b;",
                        "    }",
                        "",
                        "    public int addiere(int a, int b, int c) {",
                        "        return a + b + c;",
                        "    }",
                        "}",
                        "",
                        "public class Main {",
                        "    public static void main(String[] args) {",
                        "        Rechner rechner = new Rechner();",
                        "        System.out.println(rechner.addiere(5, 3));  // Ausgabe: 8",
                        "        System.out.println(rechner.addiere(5, 3, 2));  // Ausgabe: 10",
                        "    }",
                        "}"
                    ]
                },
                {
                    "type": "sub-container-code",
                    "_comment": "Method Overriding ",
                    "content": [
                        "// Method Overriding",
                        "class Tier {",
                        "    public void macheGeraeusch() {",
                        "        System.out.println(\"Ein Geräusch\");",
                        "    }",
                        "}",
                        "",
                        "class Hund extends Tier {",
                        "    @Override",
                        "    public void macheGeraeusch() {",
                        "        System.out.println(\"Wau Wau\");",
                        "    }",
                        "}",
                        "",
                        "public class Main {",
                        "    public static void main(String[] args) {",
                        "        Tier meinTier = new Hund();",
                        "        meinTier.macheGeraeusch();  // Ausgabe: Wau Wau",
                        "    }",
                        "}"
                    ]
                },
                {
                    "type": "sub-layout",
                    "subContent": [
                        {
                            "type": "sub-text",
                            "content": "Endgültigen Code Beispiel"
                        }
                    ]
                },
                {
                    "type": "sub-container-code",
                    "_comment": "Ende Code for Grundlagen",
                    "content": [
                        "// Beispiel für eine vollständige Klasse mit verschiedenen Methodenarten",
                        "class BankKonto {",
                        "    private String inhaber;",
                        "    private String kontonummer;",
                        "    private double kontostand;",
                        "    private static double zinssatz = 0.05;  // Klassenattribut",
                        "",
                        "    public BankKonto(String inhaber, String kontonummer, double kontostand) {",
                        "        this.inhaber = inhaber;",
                        "        this.kontonummer = kontonummer;",
                        "        this.kontostand = kontostand;",
                        "    }",
                        "",
                        "    // Instanzmethode",
                        "    public void einzahlen(double betrag) {",
                        "        if (betrag > 0) {",
                        "            this.kontostand += betrag;",
                        "            System.out.println(betrag + \" eingezahlt. Neuer Kontostand: \" + this.kontostand);",
                        "        } else {",
                        "            System.out.println(\"Der Betrag muss positiv sein.\");",
                        "        }",
                        "    }",
                        "",
                        "    // Instanzmethode",
                        "    public void abheben(double betrag) {",
                        "        if (betrag > 0 && betrag <= this.kontostand) {",
                        "            this.kontostand -= betrag;",
                        "            System.out.println(betrag + \" abgehoben. Neuer Kontostand: \" + this.kontostand);",
                        "        } else {",
                        "            System.out.println(\"Nicht genügend Guthaben oder ungültiger Betrag.\");",
                        "        }",
                        "    }",
                        "",
                        "    // Klassenmethode",
                        "    public static void setzeZinssatz(double neuerZinssatz) {",
                        "        if (neuerZinssatz > 0) {",
                        "            zinssatz = neuerZinssatz;",
                        "            System.out.println(\"Neuer Zinssatz: \" + zinssatz);",
                        "        } else {",
                        "            System.out.println(\"Der Zinssatz muss positiv sein.\");",
                        "        }",
                        "    }",
                        "",
                        "    // Statische Methode",
                        "    public static double berechneZinsen(double kontostand) {",
                        "        return kontostand * zinssatz;",
                        "    }",
                        "}",
                        "",
                        "public class Main {",
                        "    public static void main(String[] args) {",
                        "        BankKonto konto = new BankKonto(\"Max Mustermann\", \"12345678\", 1000);",
                        "        konto.einzahlen(200);  // Ausgabe: 200 eingezahlt. Neuer Kontostand: 1200.0",
                        "        konto.abheben(150);  // Ausgabe: 150 abgehoben. Neuer Kontostand: 1050.0",
                        "",
                        "        // Nutzung der Klassenmethode",
                        "        BankKonto.setzeZinssatz(0.03);",
                        "",
                        "        // Nutzung der statischen Methode",
                        "        double zinsen = BankKonto.berechneZinsen(1050.0);",
                        "        System.out.println(\"Berechnete Zinsen: \" + zinsen);  // Ausgabe: Berechnete Zinsen: 31.5",
                        "    }",
                        "}"
                    ]
                }
            ]
        },
        

        {
            "type": "text",
            "content": "Block 01",
            "id": "section3",
            "subContent": [
                {
                    "type": "sub-container",
                    "content": "Themen: In diesem Einführungsblock haben wir eine Wiederholung für Modul 319 gemacht und die Interfaces in Java näher kennengelernt. Ausserdem gab es eine kurze Einführung in den Bubble-Sort-Algorithmus, welchen wir am Ende noch benötigen werden, sowie eine Besprechung anderer Algorithmen."
                },
                {
                    "type": "sub-text",
                    "content": "eue Klasse als eine Art der ursprünglichen Klasse verwendet werden kann. Diese Kombination aus eue Klasse als eine Art der ursprünglichen Klasse verwendet werden kann. Diese Kombination aus eue Klasse als eine Art der ursprünglichen Klasse verwendet werden kann. Diese Kombination aus eue Klasse als eine Art der ursprünglichen Klasse verwendet werden kann. Diese Kombination aus eue Klasse als eine Art der ursprünglichen Klasse verwendet werden kann. Diese Kombination aus eue Klasse als eine Art der ursprünglichen Klasse verwendet werden kann. Diese Kombination aus ."
                }
                
            ]
        },

        {
            "type": "sub-layout",
            
            "subContent": [
                {
                    "type": "sub-text",
                    "content": "Vertiefung."
                },
                {
                    "type": "sub-text",
                    "content": "Vertiefung."
                }
            ]
        },


        {
            "type": "text",
            "content": "Block 02",
            "id": "section4",
            "subContent": [
                {
                    "type": "sub-container",
                    "content": "Themen: Im zweiten Block erhielten wir einen kurzen Überblick über Collections, insbesondere haben wir die ArrayList kennengelernt. Danach haben wir das UML-Klassendiagramm gelernt und wie man es aufbaut sowie die Beziehungen darin erkennt."
                }
               
                
            ]
        },

        {
            "type": "text",
            "content": "Block 03",
            "id": "section5",
            "subContent": [
                {
                    "type": "sub-container",
                    "content": "Themen: Im dritten Block haben wir uns mit Java-Generics beschäftigt sowie mit Sub- und Superklassen und den Hierarchien von Klassen und Interfaces. Und der Polymorphismus"
                }
               
                
            ]
        },

        {
            "type": "text",
            "content": "Block 04",
            "id": "section6",
            "subContent": [
                {
                    "type": "sub-container",
                    "content": "Themen: Im vierten Block werden wir uns mit den abstrakten Klassen beschäftigen."
                }
                
                
            ]
        },

        {
            "type": "text",
            "content": "Block 05",
            "id": "section7",
            "subContent": [
                {
                    "type": "sub-container",
                    "content": "Themen: Im fünften Block wird es eine Einführung zu Methoden und der Klasse String geben, ebenso zu JUnit-Tests und Algorithmen."
                }
               
                
            ]
        },
        {
            "type": "text",
            "content": "Block 06",
            "id": "section8",
            "subContent": [
                {
                    "type": "sub-container",
                    "content": "Themen: Im sechsten Block haben wir gelernt, aus Textaufgaben Klassendiagramme zu erstellen."
                }
                
            ]
        },

        {
            "type": "text",
            "content": "Block 07/08",
            "id": "section9",
            "subContent": [
                {
                    "type": "sub-container",
                    "content": "Themen: Im siebten und achten Block haben wir über Iterationen mittels innerer Klassen gelernt."
                }
               
                
            ]
        },
        {
            "type": "text",
            "content": "Block 09",
            "id": "section10",
            "subContent": [
                {
                    "type": "sub-container",
                    "content": "Themen: Im neunten Block haben wir über die Graphentheorie gelernt."
                }
               
                
            ]
        },
        {
            "type": "sub-layout",
            
            "subContent": [
                {
                    "type": "sub-text",
                    "content": "Vertiefung."
                },
                {
                    "type": "sub-text",
                    "content": "Vertiefung."
                }
            ]
        }
    ]
}
