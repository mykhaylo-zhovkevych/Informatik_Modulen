{
    "title": "M320",
    "mainTitle": "M320 => Objektorientiert Programmieren",
    "cards": [
        { "title": "Themen", "value": 5 },
        { "title": "Abschnitte", "value": 11 },
        { "title": "Codes", "value": 20 }
    ],
    "charts": [
        {
            "type": "verzeichnis",
            "title": "Verzeichnis",
            "items": [
                { "label": "1. Einleitung", "id": "section1" },
                { "label": "2. Grundlagen", "id": "section2" },
                { "label": "3. Block01", "id": "section3" },
                { "label": "4. Block02", "id": "section4" },
                { "label": "5. Block03", "id": "section5" },
                { "label": "6. Block04", "id": "section6" },
                { "label": "7. Block05", "id": "section7" },
                { "label": "8. Block06", "id": "section8" },
                { "label": "9. Block07/08", "id": "section9" },
                { "label": "10. Block09", "id": "section10" },

                { "label": "16. Aufgabe01", "id": "section16" },
                { "label": "17. Aufgabe02", "id": "section17" },
                { "label": "18. Aufgabe03", "id": "section18" },
                { "label": "19. Aufgabe04", "id": "section19" },

                { "label": "12. Projekt Teil01", "id": "section12" },
                { "label": "13. Projekt Teil02", "id": "section13" },
                { "label": "14. Projekt Teil03", "id": "section14" },
                { "label": "15. Projekt Teil04", "id": "section15" },
                
                { "label": "20. Abschlussauswertung", "id": "section20" }
            ]
        }
    ],
    "mainTextContent": [
        {
            "type": "text",
            "content": "Einleitung",
            "id": "section1",
            "subContent": [
                {
                    "type": "HandlungsZiele",
                    "ziel": "Kompetenz: Applikationen und Schnittstellen objektorientiert modellieren, implementieren, testen und dokumentieren. Objekt: Anwendung mit 3 bis 5 fachlichen Klassen.",
                    "HandlungsnotwendigeKenntnisse": [
                        "Kennt den objektorientierten Ansatz mit den Grundkonzepten Kapselung, Vererbung und Polymorphie.",
                        "Kennt Vorgehensprinzipien zur Klassenfindung (z.B. Spezialisierung und Generalisierung, Domänenmodell und –Events, BoundedContext, DRY, SRP).",
                        "Kennt Abstraktionskonzepte wie Assoziationen, Klassen, Attribute und Methoden, Schnittstellen und abstrakte Klassen und Datentypen (ADT, Collections, Generics).",
                        "Kennt Beschreibungen (z.B. CRC-Card) und Diagrammnotationen (z.B. UML, TAM, 4+1) für statische und dynamische Aspekte von objektorientiertem Design.",
                        "Kennt das Dokumentieren mit einer Dokumentationsinfrastruktur (z.B. Javadoc).",
                        "Kennt den Unterschied zwischen Klassen und Objekten. Kennt eine objektorientierte Sprache und deren Elemente und kann damit das Design umsetzen.",
                        "Kennt das Konzept der dynamischen Bindung. Kennt das Konzept der Inversion of Control (DependencyInjection)",
                        "Kennt Verfahren zum Erstellen von Testfällen. Kennt Testmethoden zur Überprüfung der Komponenten einer Anwendung (automatisches Unit-Testing)."
                    ]
                }
            ]
        },
        {
            "type": "text",
            "content": "Grundlagen",
            "id": "section2",
            "subContent": [
                {
                    "_comment": "Start of OOP",
                    "type": "sub-text",
                    "content": "Definition => Objektorientiertes Denken: Beim objektorientierten Denken geht es darum, Probleme und Lösungen in Form von Objekten zu modellieren. Man stellt sich vor, wie die verschiedenen Objekte interagieren und zusammenarbeiten, um das gewünschte Verhalten des Systems zu erreichen. Dabei werden die Prinzipien der Kapselung, Vererbung und Polymorphismus genutzt, um ein flexibles, erweiterbares und wartbares System zu entwickeln."
                },
                {
                    "_comment": "What is Object",
                    "type": "sub-text",
                    "content": "Definition => Ein Objekt ist eine Instanz einer Klasse. Wenn eine Klasse wie eine Schablone ist, dann ist ein Objekt ein konkretes Exemplar, das nach dieser Schablone erstellt wurde. Jedes Objekt hat seinen eigenen Zustand, der durch die Attribute der Klasse definiert wird."
                },
                {
                    "_comment": "What is Class",
                    "type": "sub-text",
                    "content": "Definition => Eine Klasse ist ein Bauplan oder eine Vorlage für Objekte. Sie definiert, welche Attribute und Methoden die Objekte dieser Klasse haben werden. Man kann sich eine Klasse wie eine Schablone vorstellen."
                },
                {
                    "_comment": "What is Attribute",
                    "type": "sub-text",
                    "content": "Definition => Attribute sind Variablen, die den Zustand eines Objekts beschreiben. Zum Beispiel könnte ein Auto-Objekt Attribute wie Farbe, Marke und Geschwindigkeit haben."
                },
                {
                    "_comment": "Datatypen und Variablen",
                    "type": "sub-text",
                    "content": "Unterschied zwischen Generische Typen und Konkrete Typen. => Generische Typen ermöglichen es, wiederverwendbare und flexible Code-Strukturen zu definieren, die mit verschiedenen Typen arbeiten können. Konkrete Typen hingegen sind spezifische Instanzen dieser Strukturen oder anderer Typen, die in einem bestimmten Kontext verwendet werden. Generics tragen zur Verbesserung der Typsicherheit und Lesbarkeit bei, während konkrete Typen die tatsächlichen Datenstrukturen und Objekte darstellen, mit denen Ihr Programm arbeitet."
                },
                {
                    "type": "image",
                    "src": "/imgs/320-Datentyp-Diagramm.png",
                    "alt": "404 img",
                    "id": "section2"
                },
                {
                    "type": "sub-layout",
                    "subContent": [
                        {
                            "type": "sub-text",
                            "content": "Ein konkreter Typ ist ein Datentyp, der vollständig definiert und instanziierbar ist. Diese Typen haben eine spezifische Implementierung und können direkt zur Erstellung von Objekten verwendet werden. Konkrete Typen können sowohl primitive als auch Referenztypen sein."
                        },
                        {
                            "type": "sub-text",
                            "content": "Referenztypen sind Verweise auf Objekte und keine primitiven Werte. Sie umfassen Klassen, Arrays, Schnittstellen und Enumerationen.     Klassen-Typ => definiert eine Klasse, die Daten und Methoden enthält.   Schnittstellen-Typ => definiert Methoden, die von Klassen implementiert werden können.  Array-Typ => ein Containerobjekt, das eine feste Anzahl von Werten desselben Typs speichert.    Aufzählungstyp (enum) => ein spezieller Datentyp, der eine feste Menge an Konstanten definiert."
                        },
                        
                        
                        {
                            "type": "sub-text",
                            "content": "Einfacher (elementarer, primitiver) Typ =>     Logischer Typ: boolean: Repräsentiert zwei Werte: true (wahr) und false (falsch).    Numerischer Typ:    Integer-Typen: byte: 8-Bit vorzeichenbehafteter ganzzahliger Typ. short: 16-Bit vorzeichenbehafteter ganzzahliger Typ. int: 32-Bit vorzeichenbehafteter ganzzahliger Typ. long: 64-Bit vorzeichenbehafteter ganzzahliger Typ. char: 16-Bit Unicode-Zeichen.     Gleitpunkt-Typen: float: 32-Bit Gleitkommazahl im IEEE 754 Standard. double: 64-Bit Gleitkommazahl im IEEE 754 Standard."
                        },

                        {
                            "type": "sub-text",
                            "content": "Generische Typen ermöglichen es, Klassen, Schnittstellen und Methoden zu definieren, die mit verschiedenen Datentypen arbeiten können, ohne den Code für jeden spezifischen Datentyp neu schreiben zu müssen. Sie bieten eine Möglichkeit, Typenparameter zu verwenden, die zur Kompilierzeit festgelegt werden."
                        }
                    ]
                },
                {
                    "type": "sub-container-code",
                    "_comment": "",
                    "content": [
                        "// Beispiel eines konkreten Typs",
                        "String text = \"Hallo Welt\";",
                        "int zahl = 42;",
                        "",
                        "// Eine generische Klasse",
                        "public class Box<T> {",
                        "    private T content;",
                        "",
                        "    public void setContent(T content) {",
                        "        this.content = content;",
                        "    }",
                        "",
                        "    public T getContent() {",
                        "        return content;",
                        "    }",
                        "}",
                        "",
                        "// Verwendung der generischen Klasse mit einem konkreten Typ",
                        "Box<String> stringBox = new Box<>();",
                        "stringBox.setContent(\"Hallo Welt\");",
                        "",
                        "Box<Integer> integerBox = new Box<>();",
                        "integerBox.setContent(42);"
                      ]
                },
                {
                    "_comment": "Datatypen und Variablen",
                    "type": "sub-text",
                    "content": "Zusammenfassend => Konkreter Typ: Ein fest definierter und instanziierbarer Datentyp wie int, String, ArrayList, etc. Generischer Typ: Ein Typ, der mit verschiedenen Datentypen arbeiten kann, ohne dass der Code für jeden spezifischen Typ neu geschrieben werden muss, wie ArrayList<T>, Box<T>, etc."
                },
                {
                    "_comment": "Weitere Datatypen",
                    "type": "sub-text-important",
                    "content": "In Java wird eine Variable mit ihrer Deklaration gleichzeitig definiert, was bedeutet, dass Speicherplatz für die Variable reserviert wird. Es bedeutet, dass Definition = Deklaration + Reservierung des Speicherplatzes. Bei der Deklaration versteht man der Typ und der Name der Variablen und Die Definition einer Variablen umfasst sowohl die Deklaration als auch die Reservierung von Speicherplatz. In Java wird die Deklaration einer Variablen gleichzeitig als Definition angesehen. Unterschied zu anderen Programmiersprachen => C: In der Programmiersprache C ist es möglich, eine Variable an einer Stelle zu deklarieren und sie an einer anderen Stelle zu definieren. Java: Deklaration und Definition erfolgen gleichzeitig."
                },
                {
                    "_comment": "Weitere Datatypen",
                    "type": "sub-text",
                    "content": "Unterscheidung zwischen zwei breiteren Kategorien von Variablen - dynamische und statische. In diesem Zusammenhang beziehen sich 'dynamisch' und 'statisch' auf die Bindung oder das Verhalten von Variablen. Lassen Sie uns diese Konzepte detaillierter betrachten. "
                },
                {
                    "type": "sub-layout",
                    "subContent": [
                        {
                            "type": "sub-text",
                            "content": "Definition => Dynamische Variablen sind Variablen, deren Speicherbindung und/oder Wert zur Laufzeit (dynamisch) erfolgen. In Java bezieht sich dies in der Regel auf Instanzvariablen, die zu Objekten gehören. "
                        },
                        {
                            "type": "sub-text",
                            "content": "Merkmale => Lebensdauer: Dynamische Variablen existieren nur so lange, wie die Instanz, zu der sie gehören, existiert. Speicherort: Dynamische Variablen werden im Heap-Speicher gespeichert. Bindung: Die Bindung erfolgt zur Laufzeit, wenn eine Instanz der Klasse erstellt wird."
                        }
                        
                    ]
                },
                {
                    "type": "sub-container-code",
                    "_comment": "",
                    "content": [
                        "class MyClass {",
                        "    int instanceVariable; // Dynamische Variable",
                        "",
                        "    MyClass(int value) {",
                        "        this.instanceVariable = value;",
                        "    }",
                        "",
                        "    void display() {",
                        "        System.out.println(\"Instance Variable: \" + instanceVariable);",
                        "    }",
                        "",
                        "    public static void main(String[] args) {",
                        "        MyClass obj1 = new MyClass(10);",
                        "        MyClass obj2 = new MyClass(20);",
                        "",
                        "        obj1.display(); // Ausgabe: Instance Variable: 10",
                        "        obj2.display(); // Ausgabe: Instance Variable: 20",
                        "    }",
                        "}"
                    ]
                },
                {
                    "type": "sub-layout",
                    "subContent": [
                        {
                            "type": "sub-text",
                            "content": "Definition => Statische Variablen sind Variablen, die während der Kompilierung (statisch) gebunden werden und deren Speicherbindung während der gesamten Programmausführung konstant bleibt. Dies kann sowohl auf Variablen innerhalb von Klassen (Klassenvariablen) als auch auf lokale Variablen zutreffen."
                        },
                        {
                            "type": "sub-text",
                            "content": "Merkmale   =>   Lebensdauer: Die Lebensdauer kann variieren, abhängig von der Art der statischen Variable:         Klassenvariablen: Existieren für die gesamte Laufzeit des Programms.         Lokale Variablen: Existieren nur innerhalb des Bereichs, in dem sie deklariert wurden.     Speicherort: Speicherort variiert:         Klassenvariablen: Im statischen Speicherbereich.         Lokale Variablen: Im Stack-Speicher.     Bindung: Die Bindung erfolgt zur Kompilierzeit (statisch)."
                        }
                        
                    ]
                },
                {
                    "type": "sub-container-code",
                    "_comment": "",
                    "content": [
                        "// Beispiel für Klassenvariablen",
                        "class MyClass {",
                        "    static int staticVariable = 0; // Statische Klassenvariable",
                        "",
                        "    void increment() {",
                        "        staticVariable++;",
                        "    }",
                        "",
                        "    public static void main(String[] args) {",
                        "        MyClass obj1 = new MyClass();",
                        "        MyClass obj2 = new MyClass();",
                        "",
                        "        obj1.increment();",
                        "        System.out.println(MyClass.staticVariable); // Ausgabe: 1",
                        "",
                        "        obj2.increment();",
                        "        System.out.println(MyClass.staticVariable); // Ausgabe: 2",
                        "    }",
                        "}",
                        "",
                        "// Beispiel für lokale Variablen",
                        "public class Main {",
                        "    public static void main(String[] args) {",
                        "        int localVar = 10; // Statische lokale Variable (in Bezug auf ihre Lebensdauer innerhalb der Methode)",
                        "        System.out.println(localVar); // Ausgabe: 10",
                        "    }",
                        "}"
                    ]
                },
                {
                    "_comment": "",
                    "type": "sub-text-important",
                    "content": "Instanzvariablen:      Werden automatisch mit einem Standardwert initialisiert, wenn ein Objekt der Klasse erstellt wird.     Beispiel: int wird zu 0, boolean wird zu false, Objektreferenzen werden zu null.  Klassenvariablen (statische Variablen):      Werden ebenfalls automatisch mit einem Standardwert initialisiert, wenn die Klasse geladen wird.     Beispiel: int wird zu 0, boolean wird zu false, Objektreferenzen werden zu null.  Lokale Variablen:      Werden nicht automatisch initialisiert. Der Compiler überprüft, ob eine lokale Variable initialisiert wurde, bevor sie verwendet wird."
                },
                {
                    "type": "sub-container-code",
                    "_comment": "",
                    "content": [
                        "/ / Beispiele: Instanzvariablen und Klassenvariablen",
                        "class MyClass {",
                        "    int instanceVariable;       // Instanzvariable, wird automatisch auf 0 gesetzt",
                        "    static int classVariable;   // Klassenvariable, wird automatisch auf 0 gesetzt",
                        "",
                        "    void displayValues() {",
                        "        System.out.println(\"Instance Variable: \" + instanceVariable);  // Ausgabe: 0",
                        "        System.out.println(\"Class Variable: \" + classVariable);        // Ausgabe: 0",
                        "    }",
                        "}",
                        "",
                        "public class Main {",
                        "    public static void main(String[] args) {",
                        "        MyClass obj = new MyClass();",
                        "        obj.displayValues();",
                        "    }",
                        "}",
                        "",
                        "/ / Beispiele: Lokale Variablen",
                        "public class Main {",
                        "    public static void main(String[] args) {",
                        "        int localVar; // Lokale Variable, nicht initialisiert",
                        "",
                        "        // Versuch, die lokale Variable zu verwenden, führt zu einem Compiler-Fehler:",
                        "        // System.out.println(localVar); // Fehler: Variable localVar might not have been initialized",
                        "",
                        "        // Initialisierung der lokalen Variable",
                        "        localVar = 10;",
                        "        System.out.println(\"Local Variable: \" + localVar); // Ausgabe: 10",
                        "    }",
                        "}"
                    ]
                },
                {
                    "_comment": "",
                    "type": "sub-text",
                    "content": " Definition => Eine konstante Variable ist eine Variable, deren Wert nach der Initialisierung nicht mehr verändert werden kann. In Java wird eine konstante Variable mit dem Schlüsselwort final deklariert. Konstante Variablen werden oft verwendet, um feste Werte zu definieren, die während der Programmausführung unverändert bleiben sollen."
                },
                {
                    "type": "sub-container-code",
                    "_comment": "",
                    "content": [
                        "import java.util.*;",
                        "",
                        "public class MyClass {",
                        "    // Deklaration und Initialisierung einer konstanten Klassenvariable",
                        "    public static final int MAX_USERS = 100;",
                        "",
                        "    // Deklaration und Initialisierung einer konstanten Instanzvariable",
                        "    public final String MY_CONSTANT;",
                        "",
                        "    // Initialisierung der konstanten Instanzvariable im Konstruktor",
                        "    public MyClass(String value) {",
                        "        MY_CONSTANT = value;",
                        "    }",
                        "",
                        "    public void displayConstants() {",
                        "        System.out.println(\"Max Users: \" + MAX_USERS);",
                        "        System.out.println(\"My Constant: \" + MY_CONSTANT);",
                        "    }",
                        "",
                        "    public static void main(String[] args) {",
                        "        MyClass obj = new MyClass(\"Hellfo\");",
                        "        obj.displayConstants();",
                        "",
                        "        // Versuch, eine konstante Variable zu ändern, führt zu einem Compiler-Fehler:",
                        "        // MAX_USERS = 200; // Fehler: cannot assign a value to final variable MAX_USERS",
                        "        // obj.MY_CONSTANT = \"World\"; // Fehler: cannot assign a value to final variable MY_CONSTANT",
                        "    }",
                        "}"
                    ]
                },  
                {
                    "_comment": "What is Methods",
                    "type": "sub-text-important",
                    "content": " Definition => Block ist eine folge von Anweisungen, die sequenziell hintereinander ausgeführt wird. Eine Methode ist eine Folge von Anweisungne, die unter einem Namen aufgerufen werden kann."
                },
                {
                    "_comment": "What is Methods",
                    "type": "sub-text",
                    "content": " Definition => Methoden in der OOP sind Funktionen, die innerhalb einer Klasse definiert sind und das Verhalten der Objekte dieser Klasse beschreiben. Zweck => Sie ermöglichen es Objekten, Aktionen auszuführen und auf ihre eigenen Daten zuzugreifen oder diese zu verändern."
                },
                {
                    "type": "sub-layout",
                    "subContent": [
                        {
                            "type": "sub-text",
                            "content": "Definition => Instanzmethoden sind Methoden, die auf einer Instanz einer Klasse arbeiten. Diese Methoden können auf die Attribute (Instanzvariablen) des Objekts zugreifen und diese verändern. Sie werden über ein Objekt der Klasse aufgerufen. Zweck => Instanzmethoden werden verwendet, um Verhalten zu definieren, das spezifisch für einzelne Objekte ist. Sie ermöglichen es den Objekten, Aktionen auszuführen und auf ihren Zustand zu reagieren."
                        },
                        {
                            "type": "sub-text",
                            "content": "Definition => Klassenmethoden sind Methoden, die auf der Klasse selbst und nicht auf Instanzen der Klasse arbeiten. Sie werden in Java mit dem Schlüsselwort static deklariert. Zweck => Klassenmethoden werden verwendet, um Verhalten zu definieren, das sich auf die Klasse als Ganzes bezieht, anstatt auf einzelne Instanzen. Sie sind nützlich für: Utility- oder Hilfsfunktionen, die allgemeine Operationen durchführen, die nicht von einer bestimmten Instanz abhängen. Und Zugriff auf Klassenvariablen: Sie können auf statische Variablen der Klasse zugreifen und diese manipulieren, da diese ebenfalls zur Klasse und nicht zu einer Instanz gehören."
                        },
                        {
                            "type": "sub-text",
                            "content": "Definition => Statische Methoden sind eine spezielle Art von Klassenmethoden, die unabhängig von Instanzen der Klasse sind. Sie benötigen keine Referenz auf ein Objekt der Klasse und können direkt über die Klasse aufgerufen werden. Zweck => Statische Methoden sind besonders nützlich für: Allgemeine Utility-Funktionen: Funktionen, die keine Informationen über den Zustand einer bestimmten Instanz benötigen und somit unabhängig von Instanzvariablen sind. Und  Kapselung von Funktionen: Sie bieten eine Möglichkeit, allgemeine Funktionen innerhalb der Klasse zu kapseln, die weder Instanzvariablen noch Methoden benötigen."
                        }
                    ]
                },
                {
                    "type": "sub-container-code",
                    "_comment": "Instanzmethoden Code",
                    "content": [
                        "// Instanzmethoden",
                        "class Auto {",
                        "    private String farbe;",
                        "    private String marke;",
                        "",
                        "    public Auto(String farbe, String marke) {",
                        "        this.farbe = farbe;",
                        "        this.marke = marke;",
                        "    }",
                        "",
                        "    public void fahren(int geschwindigkeit) {",
                        "        System.out.println(\"Das \" + this.marke + \" Auto fährt mit \" + geschwindigkeit + \" km/h.\");",
                        "    }",
                        "}",
                        "",
                        "public class Main {",
                        "    public static void main(String[] args) {",
                        "        Auto meinAuto = new Auto(\"Rot\", \"BMW\");",
                        "        meinAuto.fahren(100);  // Ausgabe: Das BMW Auto fährt mit 100 km/h.",
                        "    }",
                        "}"
                    ]
                },
                {
                    "type": "sub-container-code",
                    "_comment": "Klassenmethoden Code",
                    "content": [
                        "// Klassenmethoden",
                        "class Auto {",
                        "    private String farbe;",
                        "    private String marke;",
                        "    private static int anzahlAutos = 0;",
                        "",
                        "    public Auto(String farbe, String marke) {",
                        "        this.farbe = farbe;",
                        "        this.marke = marke;",
                        "        anzahlAutos++;",
                        "    }",
                        "",
                        "    public static void zeigeAnzahlAutos() {",
                        "        System.out.println(\"Es gibt \" + anzahlAutos + \" Autos.\");",
                        "    }",
                        "}",
                        "",
                        "public class Main {",
                        "    public static void main(String[] args) {",
                        "        Auto auto1 = new Auto(\"Rot\", \"BMW\");",
                        "        Auto auto2 = new Auto(\"Blau\", \"Audi\");",
                        "        Auto.zeigeAnzahlAutos();  // Ausgabe: Es gibt 2 Autos.",
                        "    }",
                        "}"
                    ]
                },
                {
                    "type": "sub-container-code",
                    "_comment": "Statische Methoden Code",
                    "content": [
                        "// Statische Methoden",
                        "class MathUtils {",
                        "    public static int addiere(int a, int b) {",
                        "        return a + b;",
                        "    }",
                        "}",
                        "",
                        "public class Main {",
                        "    public static void main(String[] args) {",
                        "        int summe = MathUtils.addiere(5, 3);",
                        "        System.out.println(\"Die Summe ist: \" + summe);  // Ausgabe: Die Summe ist: 8",
                        "    }",
                        "}"
                    ]
                },
                {
                    "type": "sub-text",
                    "content": "Unterschiede zwischen Klassenmethoden und statischen Methodenm => In Java gibt es keinen funktionalen Unterschied zwischen Klassenmethoden und statischen Methoden, da beide mit dem Schlüsselwort static deklariert werden und auf dieselbe Weise verwendet werden. Der Begriff 'statische Methode' wird oft synonym mit 'Klassenmethode' verwendet. Der Unterschied liegt mehr in der Perspektive und dem Kontext der Nutzung: Klassenmethoden: Der Fokus liegt darauf, dass diese Methoden zur Klasse gehören und Klassenvariablen verwenden können. Sie sind Teil des Verhaltens der Klasse als Ganzes. Statische Methoden: Der Fokus liegt darauf, dass diese Methoden unabhängig von Instanzen sind. Sie kapseln allgemeine Funktionen, die keinen Zugriff auf Instanzvariablen oder Instanzmethoden benötigen."
                    
                },
                {
                    "type": "sub-layout",
                    "subContent": [
                        {
                            "_comment": "Method Overloading",
                            "type": "sub-text",
                            "content": "Definition => Method Overloading bedeutet, dass mehrere Methoden in einer Klasse denselben Namen haben, sich aber in der Anzahl oder den Typen der Parameter unterscheiden. Es ermöglicht es, ähnliche Methoden mit unterschiedlichen Signaturen zu definieren. Zweck => Method Overloading wird verwendet, um Methoden zu definieren, die ähnliche Operationen ausführen, aber unterschiedliche Parameter akzeptieren. Es verbessert die Lesbarkeit und Wartbarkeit des Codes, indem es die Methode für verschiedene Eingabetypen anpasst."
                        },
                        {
                            "_comment": "Method Overriding",
                            "type": "sub-text",
                            "content": "Definition => Method Overriding bedeutet, dass eine Methode in einer Subklasse die gleiche Signatur wie eine Methode in der Superklasse hat und deren Verhalten überschreibt. Es ermöglicht es, die spezifische Implementierung einer Methode in einer abgeleiteten Klasse anzupassen. Zweck => Method Overriding wird verwendet, um das Verhalten einer geerbten Methode in einer Subklasse zu ändern oder zu erweitern. Es ermöglicht die Nutzung von Polymorphismus und stellt sicher, dass eine Methode in der Subklasse eine spezifische Implementierung hat."
                        }
                    ]
                },
                {
                    "type": "sub-container-code",
                    "_comment": "Method Overloading ",
                    "content": [
                        "// Method Overloading",
                        "class Rechner {",
                        "    public int addiere(int a, int b) {",
                        "        return a + b;",
                        "    }",
                        "",
                        "    public int addiere(int a, int b, int c) {",
                        "        return a + b + c;",
                        "    }",
                        "}",
                        "",
                        "public class Main {",
                        "    public static void main(String[] args) {",
                        "        Rechner rechner = new Rechner();",
                        "        System.out.println(rechner.addiere(5, 3));  // Ausgabe: 8",
                        "        System.out.println(rechner.addiere(5, 3, 2));  // Ausgabe: 10",
                        "    }",
                        "}"
                    ]
                },
                {
                    "type": "sub-container-code",
                    "_comment": "Method Overriding ",
                    "content": [
                        "// Method Overriding",
                        "class Tier {",
                        "    public void macheGeraeusch() {",
                        "        System.out.println(\"Ein Geräusch\");",
                        "    }",
                        "}",
                        "",
                        "class Hund extends Tier {",
                        "    @Override",
                        "    public void macheGeraeusch() {",
                        "        System.out.println(\"Wau Wau\");",
                        "    }",
                        "}",
                        "",
                        "public class Main {",
                        "    public static void main(String[] args) {",
                        "        Tier meinTier = new Hund();",
                        "        meinTier.macheGeraeusch();  // Ausgabe: Wau Wau",
                        "    }",
                        "}"
                    ]
                },
                {
                    "type": "sub-layout",
                    "subContent": [
                        {
                            "type": "sub-text",
                            "content": "Endgültigen Code Beispiel"
                        }
                    ]
                },
                {
                    "type": "sub-container-code",
                    "_comment": "Ende Code for Grundlagen",
                    "content": [
                        "// Beispiel für eine vollständige Klasse mit verschiedenen Methodenarten",
                        "class BankKonto {",
                        "    private String inhaber;",
                        "    private String kontonummer;",
                        "    private double kontostand;",
                        "    private static double zinssatz = 0.05;  // Klassenattribut",
                        "",
                        "    public BankKonto(String inhaber, String kontonummer, double kontostand) {",
                        "        this.inhaber = inhaber;",
                        "        this.kontonummer = kontonummer;",
                        "        this.kontostand = kontostand;",
                        "    }",
                        "",
                        "    // Instanzmethode",
                        "    public void einzahlen(double betrag) {",
                        "        if (betrag > 0) {",
                        "            this.kontostand += betrag;",
                        "            System.out.println(betrag + \" eingezahlt. Neuer Kontostand: \" + this.kontostand);",
                        "        } else {",
                        "            System.out.println(\"Der Betrag muss positiv sein.\");",
                        "        }",
                        "    }",
                        "",
                        "    // Instanzmethode",
                        "    public void abheben(double betrag) {",
                        "        if (betrag > 0 && betrag <= this.kontostand) {",
                        "            this.kontostand -= betrag;",
                        "            System.out.println(betrag + \" abgehoben. Neuer Kontostand: \" + this.kontostand);",
                        "        } else {",
                        "            System.out.println(\"Nicht genügend Guthaben oder ungültiger Betrag.\");",
                        "        }",
                        "    }",
                        "",
                        "    // Klassenmethode",
                        "    public static void setzeZinssatz(double neuerZinssatz) {",
                        "        if (neuerZinssatz > 0) {",
                        "            zinssatz = neuerZinssatz;",
                        "            System.out.println(\"Neuer Zinssatz: \" + zinssatz);",
                        "        } else {",
                        "            System.out.println(\"Der Zinssatz muss positiv sein.\");",
                        "        }",
                        "    }",
                        "",
                        "    // Statische Methode",
                        "    public static double berechneZinsen(double kontostand) {",
                        "        return kontostand * zinssatz;",
                        "    }",
                        "}",
                        "",
                        "public class Main {",
                        "    public static void main(String[] args) {",
                        "        BankKonto konto = new BankKonto(\"Max Mustermann\", \"12345678\", 1000);",
                        "        konto.einzahlen(200);  // Ausgabe: 200 eingezahlt. Neuer Kontostand: 1200.0",
                        "        konto.abheben(150);  // Ausgabe: 150 abgehoben. Neuer Kontostand: 1050.0",
                        "",
                        "        // Nutzung der Klassenmethode",
                        "        BankKonto.setzeZinssatz(0.03);",
                        "",
                        "        // Nutzung der statischen Methode",
                        "        double zinsen = BankKonto.berechneZinsen(1050.0);",
                        "        System.out.println(\"Berechnete Zinsen: \" + zinsen);  // Ausgabe: Berechnete Zinsen: 31.5",
                        "    }",
                        "}"
                    ]
                }
            ]
        },
        

        {
            "type": "text",
            "content": "Block 01",
            "id": "section3",
            "subContent": [
                {
                    "type": "sub-container",
                    "content": "Themen: In diesem Einführungsblock haben wir eine Wiederholung für Modul 319 gemacht und die Interfaces, Modifikatoren in Java näher kennengelernt. Ausserdem gab es eine kurze Einführung in den Bubble-Sort-Algorithmus, welchen wir am Ende noch benötigen werden, sowie eine Besprechung anderer Algorithmen."
                },
                {
                    "type": "sub-text",
                    "content": "abstract => Definiert eine Klasse oder Methode als abstrakt. final => Verhindert, dass eine Klasse erweitert, eine Methode überschrieben oder eine Variable verändert wird. private => Macht das Element nur innerhalb der Klasse sichtbar. protected => Macht das Element innerhalb der Klasse und in Unterklassen sichtbar, auch in anderen Paketen. public => Macht das Element überall sichtbar. static => Markiert ein Element als zugehörig zur Klasse anstatt zu Instanzen der Klasse. synchronized => Stellt sicher, dass nur ein Thread gleichzeitig auf die Methode zugreifen kann. transient => Verhindert, dass ein Datenfeld beim Serialisieren gespeichert wird. volatile => Macht ein Datenfeld direkt im Hauptspeicher sichtbar, wodurch alle Threads sofort die Änderungen sehen."
                },
                {
                    "type": "image",
                    "src": "/imgs/320-modifikatoren.jpg",
                    "alt": "404 img",
                    "id": "section3"
                },
                {
                    "type": "image",
                    "src": "/imgs/320-img-block02-modi.png",
                    "alt": "404 img",
                    "id": "section3"
                },
                {
                    "type": "HandlungsZiele",
                    "ziel": "Was ist ein Interface?",
                    "HandlungsnotwendigeKenntnisse": [
                        "Ein Interface ist eine Schnittstelle, in der festgelegt wird, über welche Methoden die Klassen, die das Interface implementieren, verfügen müssen. Die Interfaces selber enthalten daher nur Funktionsköpfe und Konstanten. Alle Klassen, die das Interface implementieren, müssen sämtliche Methoden, die das Interface vorgibt, enthalten.",
                        "Interfaces werden verwendet, um Gemeinsamkeiten (z.B. gleiche Funktionalitäten), die mehreren Klassen zugrunde liegen, in einer separaten Klasse zu definieren.(Implementierung durch Klassen: Jede Klasse, die das Interface benutzt, muss den Code für diese Aufgaben bereitstellen.) Die Objekte der implementierenden Klasse sind wie bei der Vererbung dann gleichzeitig auch Objekte des Interfaces. In Java werden Interfaces daher oft genutzt, um die fehlende Mehrfachvererbung gewissermassen zu simulieren, da eine Klasse zwar nur von einer Superklasse abgeleitet werden kann, jedoch beliebig viele Interfaces implementieren kann. ",    
                        "In der Praxis werden Interfaces häufig für Kommunikationszwecke verwendet. Zwei miteinander kommunizierende Seiten besitzen beispielsweise ein festgelegtes Interface, damit eine reibungslose Kommunikation durchgeführt werden kann. So wird gewährleistet, dass beide Seiten die vom Interface vorgegebenen Methoden implementieren.",
                        "Das Interface dient auch dazu, den eigenen Quellcode vor fremden Entwicklern zu schützen, da diese nur auf die Methoden des Interfaces zugreifen können. Entwickler, die das Interface nutzen, können nur auf die Methoden zugreifen, die im Interface definiert sind, und nicht auf die internen Implementierungsdetails der Klasse. Dies fördert die Kapselung und verhindert unerwünschte Änderungen oder Zugriffe auf den internen Zustand der Klasse."
                    ]    
                },
                {
                    "_comment": "",
                    "type": "sub-text-important",
                    "content": "Ein Funktionskopf oder eine Methodensignatur ist die Definition einer Methode ohne ihren eigentlichen Implementierungscode. Sie gibt den Namen der Methode, ihren Rückgabewert und die Parameter, die sie erwartet, an, enthält aber keinen Code, der ausgeführt wird."
                },
                {
                    "_comment": "",
                    "type": "sub-text-important",
                    "content": "Konstanten sind Variablen, deren Wert nach der Initialisierung nicht mehr geändert werden kann. In einem Interface sind alle Variablen automatisch public, static und final. Das bedeutet, dass sie für alle Implementierungen des Interfaces zugänglich sind, zur Klasse gehören (nicht zur Instanz) und unveränderlich sind."
                },
                {
                    "type": "sub-container-code",
                    "_comment": "",
                    "content": [
                        "public interface Animal {",
                        "    // Konstante (public, static, final)",
                        "    int MAX_AGE = 20;",
                        "    ",
                        "    // Methodensignaturen (Funktionsköpfe)",
                        "    void eat();",
                        "    void sleep();",
                        "}",
                        "",
                        "// Implementierende Klasse",
                        "class Dog implements Animal {",
                        "    public void eat() {",
                        "        System.out.println(\"Dog eats\");",
                        "    }",
                        "",
                        "    public void sleep() {",
                        "        System.out.println(\"Dog sleeps\");",
                        "    }",
                        "    ",
                        "    void showMaxAge() {",
                        "        System.out.println(\"Max age is \" + MAX_AGE);",
                        "    }",
                        "}",
                        "",
                        "public class Main {",
                        "    public static void main(String[] args) {",
                        "        Dog dog = new Dog();",
                        "        dog.eat();",
                        "        dog.sleep();",
                        "        dog.showMaxAge(); // Ausgabe: Max age is 20",
                        "    }",
                        "}"
                    ]
                },
                {
                    "type": "HandlungsZiele",
                    "ziel": "Vererbung und Interfaces in Java",
                    "HandlungsnotwendigeKenntnisse": [
                        "Vererbung => In Java kann eine Klasse nur von einer anderen Klasse erben. Das bedeutet, eine Klasse kann nur eine direkte Elternklasse haben. ",    
                        "Interfaces => Eine Klasse kann mehrere Interfaces implementieren. Wenn eine Klasse ein Interface implementiert, ist sie verpflichtet, alle Methoden dieses Interfaces zu definieren. Objekte der Klasse, die ein Interface implementiert, können auch als Objekte des Interfaces betrachtet werden."
                    ]    
                },
                {
                    "type": "sub-layout",
                    "subContent": [
                        {
                            "_comment": "",
                            "type": "sub-text",
                            "content": "Simulation der Mehrfachvererbung"
                        }
                    ]
                },
                {
                    "type": "sub-container-code",
                    "_comment": "",
                    "content": [
                        "// Beweglich.java",
                        "public interface Beweglich {",
                        "    void fahren();",
                        "}",
                        "",
                        "// Schwimmfähig.java",
                        "public interface Schwimmfähig {",
                        "    void schwimmen();",
                        "}",
                        "",
                        "// AmphibienFahrzeug.java",
                        "public class AmphibienFahrzeug implements Beweglich, Schwimmfähig {",
                        "    @Override",
                        "    public void fahren() {",
                        "        System.out.println(\"Das Amphibienfahrzeug fährt auf der Strasse.\");",
                        "    }",
                        "",
                        "    @Override",
                        "    public void schwimmen() {",
                        "        System.out.println(\"Das Amphibienfahrzeug schwimmt im Wasser.\");",
                        "    }",
                        "}",
                        "",
                        "// Main.java",
                        "public class Main {",
                        "    public static void main(String[] args) {",
                        "        AmphibienFahrzeug amphibienFahrzeug = new AmphibienFahrzeug();",
                        "",
                        "        // Das Amphibienfahrzeug kann sowohl fahren als auch schwimmen",
                        "        amphibienFahrzeug.fahren();",
                        "        amphibienFahrzeug.schwimmen();",
                        "",
                        "        // Demonstrieren der Mehrfachvererbungssimulation",
                        "        Beweglich beweglichesObjekt = amphibienFahrzeug;",
                        "        Schwimmfähig schwimmfähigesObjekt = amphibienFahrzeug;",
                        "",
                        "        // Aufruf der Methoden über die Interface-Referenzen",
                        "        beweglichesObjekt.fahren();",
                        "        schwimmfähigesObjekt.schwimmen();",
                        "    }",
                        "}"
                    ]
                },
                
                {
                    "type": "sub-layout",
                    "subContent": [
                        {
                            "_comment": "",
                            "type": "sub-text",
                            "content": "Erweiterte Simulation der Mehrfachvererbung mit Abstrakt"
                        }
                    ]
                },
                {
                    "type": "sub-container-code",
                    "_comment": "",
                    "content": [
                        "// Schritt 1: Definiere das Interface und die abstrakte Klasse",
                        "// Beweglich.java",
                        "public interface Beweglich {",
                        "    void fahren();",
                        "}",
                        "",
                        "// Schwimmfähig.java",
                        "public interface Schwimmfähig {",
                        "    void schwimmen();",
                        "}",
                        "",
                        "// Fahrzeug.java",
                        "public abstract class Fahrzeug {",
                        "    private String name;",
                        "",
                        "    public Fahrzeug(String name) {",
                        "        this.name = name;",
                        "    }",
                        "",
                        "    public String getName() {",
                        "        return name;",
                        "    }",
                        "",
                        "    public void starten() {",
                        "        System.out.println(name + \" startet.\");",
                        "    }",
                        "",
                        "    public abstract void stoppen();",
                        "}",
                        "// Schritt 2: Implementiere die Klasse, die das Interface und die abstrakte Klasse kombiniert",
                        "// AmphibienFahrzeug.java",
                        "public class AmphibienFahrzeug extends Fahrzeug implements Beweglich, Schwimmfähig {",
                        "    public AmphibienFahrzeug(String name) {",
                        "        super(name);",
                        "    }",
                        "",
                        "    @Override",
                        "    public void fahren() {",
                        "        System.out.println(getName() + \" fährt auf der Strasse.\");",
                        "    }",
                        "",
                        "    @Override",
                        "    public void schwimmen() {",
                        "        System.out.println(getName() + \" schwimmt im Wasser.\");",
                        "    }",
                        "",
                        "    @Override",
                        "    public void stoppen() {",
                        "        System.out.println(getName() + \" stoppt.\");",
                        "    }",
                        "}",
                        "// Schritt 3: Verwende die Klasse im Hauptprogramm",
                        "// Main.java",
                        "public class Main {",
                        "    public static void main(String[] args) {",
                        "        AmphibienFahrzeug amphibienFahrzeug = new AmphibienFahrzeug(\"Amphi\");",
                        "",
                        "        amphibienFahrzeug.starten();  // Von der abstrakten Klasse",
                        "        amphibienFahrzeug.fahren();   // Vom Interface Beweglich",
                        "        amphibienFahrzeug.schwimmen(); // Vom Interface Schwimmfähig",
                        "        amphibienFahrzeug.stoppen();  // Von der abstrakten Klasse",
                        "    }",
                        "}"
                    ]
                }
            ]
        },
        {
            "type": "sub-layout",
            
            "subContent": [
                {
                    "type": "sub-text",
                    "content": "Vertiefung."
                },
                {
                    "type": "sub-text",
                    "content": "Vertiefung."
                }
            ]
        },


        {
            "type": "text",
            "content": "Block 02",
            "id": "section4",
            "subContent": [
                {
                    "type": "sub-container",
                    "content": "Themen: Im zweiten Block erhielten wir einen kurzen Überblick über Collections, insbesondere haben wir die ArrayList kennengelernt. Danach haben wir das UML-Klassendiagramm gelernt und wie man es aufbaut sowie die Beziehungen darin erkennt."
                }
               
                
            ]
        },

        {
            "type": "text",
            "content": "Block 03",
            "id": "section5",
            "subContent": [
                {
                    "type": "sub-container",
                    "content": "Themen: Im dritten Block haben wir uns mit Java-Generics beschäftigt sowie mit Sub- und Superklassen und den Hierarchien von Klassen. Und der Polymorphismus, Vererbung, Verkapselung"
                },
                {
                    "type": "HandlungsZiele",
                    "ziel": "Was ist eine Vererbung",
                    "HandlungsnotwendigeKenntnisse": [
                        "Vererbung ist ein grundlegendes Konzept in der objektorientierten Programmierung, bei dem eine Klasse (Unterklasse oder Subklasse) die Eigenschaften und Methoden einer anderen Klasse (Oberklasse oder Superklasse) erbt. Dieses Konzept fördert die Wiederverwendbarkeit und Erweiterbarkeit von Code.",
                        "Hauptmerkmale der Vererbung:",
                        "1. Wiederverwendbarkeit: Durch Vererbung kann eine Unterklasse die bereits vorhandenen Eigenschaften und Methoden der Oberklasse wiederverwenden, wodurch Redundanz vermieden wird.",
                        "2. Hierarchie: Vererbung ermöglicht die Erstellung einer Klassenhierarchie, in der Unterklassen von Oberklassen erben und diese erweitern oder spezialisieren.",
                        "Erweitern: ",
                        "Die Unterklasse fügt neue Eigenschaften oder Methoden hinzu, die in der Oberklasse nicht vorhanden sind. Auf diese Weise kann die Unterklasse zusätzliche Funktionalitäten bieten, die spezifisch für sie sind.",
                        "Spezialisieren:",
                        "Die Unterklasse passt die vorhandenen Eigenschaften oder Methoden der Oberklasse an, um spezifisches Verhalten zu implementieren. Dies geschieht oft durch Überschreiben (Overriding) der Methoden der Oberklasse.",
                        "3. Erweiterbarkeit: Unterklassen können neue Eigenschaften und Methoden hinzufügen oder bestehende Methoden der Oberklasse überschreiben, um spezifisches Verhalten zu implementieren.",
                        "'is-a'-Beziehung: Vererbung beschreibt eine 'is-a'-Beziehung. Zum Beispiel ist ein Auto ein Fahrzeug, daher kann Auto von Fahrzeug erben.",
                        ""
                      
                    ]
                },
                {
                    "_comment": "",
                    "type": "sub-text-important",
                    "content": "Bei der Vererbung wird in Java der Quellcode ener einzigen Superklassen in einer abgeleleiteten Klasse wiederverwendet. In Falle einer Aggregation werden vorhandene einzele Klassen von den aggregierenden Klassen benutzt und damit wiederverwendet."
                },
                {
                    "type": "sub-container-code",
                    "_comment": "",
                    "content": [
                        "// Vorhandene Klassen",
                        "public class Motor {",
                        "    public void starten() {",
                        "        System.out.println(\"Der Motor startet.\");",
                        "    }",
                        "}",
                        "",
                        "public class Sitz {",
                        "    public void einstellen() {",
                        "        System.out.println(\"Der Sitz wird eingestellt.\");",
                        "    }",
                        "}",
                        "// Aggregierende Klasse",
                        "public class Auto {",
                        "    private Motor motor;",
                        "    private Sitz[] sitze;",
                        "",
                        "    public Auto(Motor motor, Sitz[] sitze) {",
                        "        this.motor = motor;",
                        "        this.sitze = sitze;",
                        "    }",
                        "",
                        "    public void fahren() {",
                        "        motor.starten();",
                        "        System.out.println(\"Das Auto fährt.\");",
                        "    }",
                        "",
                        "    public void sitzeEinstellen() {",
                        "        for (Sitz sitz : sitze) {",
                        "            sitz.einstellen();",
                        "        }",
                        "    }",
                        "",
                        "    public static void main(String[] args) {",
                        "        // Erstellen von Motor- und Sitzobjekten",
                        "        Motor motor = new Motor();",
                        "        Sitz[] sitze = { new Sitz(), new Sitz(), new Sitz() };",
                        "",
                        "        // Erstellen eines Auto-Objekts, das Motor und Sitze enthält",
                        "        Auto auto = new Auto(motor, sitze);",
                        "",
                        "        // Methoden des Auto-Objekts aufrufen",
                        "        auto.fahren();  // Ausgabe: Der Motor startet. Das Auto fährt.",
                        "        auto.sitzeEinstellen();  // Ausgabe: Der Sitz wird eingestellt. (dreimal)",
                        "    }",
                        "}"
                    ]
                },
                {
                    "type": "sub-container-code",
                    "_comment": "",
                    "content": [
                        "// Oberklasse: Fahrzeug",
                        "public class Fahrzeug {",
                        "    public void fahren() {",
                        "        System.out.println(\"Das Fahrzeug fährt.\");",
                        "    }",
                        "}",
                        "",
                        "// Unterklassen: MotorisiertesFahrzeug und Auto",
                        "public class MotorisiertesFahrzeug extends Fahrzeug {",
                        "    public void starten() {",
                        "        System.out.println(\"Der Motor startet.\");",
                        "    }",
                        "}",
                        "",
                        "public class Auto extends MotorisiertesFahrzeug {",
                        "    private int sitzAnzahl;",
                        "",
                        "    public Auto(int sitzAnzahl) {",
                        "        this.sitzAnzahl = sitzAnzahl;",
                        "    }",
                        "",
                        "    public void hupen() {",
                        "        System.out.println(\"Das Auto hupt.\");",
                        "    }",
                        "",
                        "    public void sitzeEinstellen() {",
                        "        for (int i = 0; i < sitzAnzahl; i++) {",
                        "            System.out.println(\"Der Sitz \" + (i + 1) + \" wird eingestellt.\");",
                        "        }",
                        "    }",
                        "",
                        "    public static void main(String[] args) {",
                        "        Auto auto = new Auto(3);",
                        "",
                        "        auto.starten(); // Ausgabe: Der Motor startet.",
                        "        auto.fahren();  // Ausgabe: Das Fahrzeug fährt.",
                        "        auto.hupen();   // Ausgabe: Das Auto hupt.",
                        "        auto.sitzeEinstellen(); // Ausgabe: Der Sitz 1 wird eingestellt.",
                        "                                //          Der Sitz 2 wird eingestellt.",
                        "                                //          Der Sitz 3 wird eingestellt.",
                        "    }",
                        "}"
                    ]
                },
                {
                    "type": "HandlungsZiele",
                    "ziel": "Unterschiede",
                    "HandlungsnotwendigeKenntnisse": [
                        "Vererbung:",
                        "Definition: Bei der Vererbung wird in Java der Quellcode einer einzigen Superklasse (Oberklasse) in einer abgeleiteten Klasse (Unterklasse) wiederverwendet. Dies ermöglicht es der Unterklasse, alle Eigenschaften und Methoden der Oberklasse zu erben und gegebenenfalls zu erweitern oder zu überschreiben.",
                        "Beispiel: In unserem Beispiel erbt MotorisiertesFahrzeug von Fahrzeug und Auto erbt wiederum von MotorisiertesFahrzeug. Dies bedeutet, dass Auto sowohl die Methoden fahren als auch starten verwenden kann, ohne sie erneut definieren zu müssen.",
                        "Aggregation:",
                        "Definition: Im Falle einer Aggregation werden vorhandene einzelne Klassen von den aggregierenden Klassen benutzt und damit wiederverwendet. Dies bedeutet, dass eine Klasse Objekte anderer Klassen enthält, um komplexere Funktionalitäten zu ermöglichen.",
                        "Beispiel: In unserem vorherigen Aggregationsbeispiel enthielt die Klasse Auto ein Objekt der Klasse Motor und ein Array von Objekten der Klasse Sitz. Die Klasse Auto nutzte diese Objekte, um ihre Methoden fahren und sitzeEinstellen zu implementieren."
                    ]
                },
                {
                    "type": "HandlungsZiele",
                    "ziel": "Kapselung (Encapsulation) in der OOP",
                    "HandlungsnotwendigeKenntnisse": [
                       "Kapselung ist ein grundlegendes Prinzip der objektorientierten Programmierung, das die Bündelung von Daten (Eigenschaften) und Methoden (Funktionen), die auf diese Daten operieren, innerhalb einer Klasse umfasst. Das Hauptziel der Kapselung ist es, den direkten Zugriff auf die Daten zu beschränken und die Datenintegrität zu gewährleisten.",
                       "Ziele:",
                       "Datenverstecken: Schutz der Daten vor unerlaubtem Zugriff und Modifikation von aussen.",
                       "Datenintegrität: Sicherstellen, dass die Daten nur über definierte Schnittstellen (Methoden) geändert werden können.",
                       "Modularität: Förderung der Modularität des Codes, indem Implementierungsdetails verborgen werden und nur notwendige Schnittstellen offengelegt werden."
                    ]
                },
                {
                    "type": "sub-container-code",
                    "_comment": "",
                    "content": [
                        "public class Bankkonto {",
                        "    private double saldo;",
                        "",
                        "    // Getter-Methode für 'saldo'",
                        "    public double getSaldo() {",
                        "        return saldo;",
                        "    }",
                        "",
                        "    // Methode zum Einzahlen",
                        "    public void einzahlen(double betrag) {",
                        "        if (betrag > 0) {",
                        "            saldo += betrag;",
                        "        } else {",
                        "            System.out.println(\"Betrag muss positiv sein.\");",
                        "        }",
                        "    }",
                        "",
                        "    // Methode zum Abheben",
                        "    public void abheben(double betrag) {",
                        "        if (betrag > 0 && betrag <= saldo) {",
                        "            saldo -= betrag;",
                        "        } else {",
                        "            System.out.println(\"Ungültiger Betrag oder nicht genügend Mittel.\");",
                        "        }",
                        "    }",
                        "",
                        "    public static void main(String[] args) {",
                        "        Bankkonto konto = new Bankkonto();",
                        "        konto.einzahlen(100);",
                        "        konto.abheben(50);",
                        "        System.out.println(\"Aktueller Saldo: \" + konto.getSaldo()); // Ausgabe: Aktueller Saldo: 50.0",
                        "    }",
                        "}"
                    ]
                },
                {
                    "_comment": "",
                    "type": "sub-text",
                    "content": "1. Die Eigenschaft saldo ist als private deklariert. Das bedeutet, dass saldo nur innerhalb der Klasse Bankkonto direkt zugänglich ist. Diese Einschränkung ist der Kern der Kapselung, da sie verhindert, dass externe Klassen oder Funktionen direkten Zugriff auf diese Eigenschaft haben. 2. Die Methode getSaldo ist public, was bedeutet, dass externe Klassen und Methoden auf den Wert von saldo zugreifen können, aber nur über diese Methode. Dies ermöglicht die Kontrolle und Validierung des Zugriffs auf saldo."
                },
                {
                    "type": "HandlungsZiele",
                    "ziel": "Polymorphismus in der OOP",
                    "HandlungsnotwendigeKenntnisse": [
                       "Polymorphismus ist ein grundlegendes Konzept in der objektorientierten Programmierung (OOP), das es Objekten ermöglicht, als Instanzen ihrer Elternklasse und nicht ihrer tatsächlichen Klasse behandelt zu werden. Der Begriff Polymorphismus stammt aus dem Griechischen und setzt sich aus den Wörtern „poly“ (viele) und „morph“ (Form) zusammen, was bedeutet, dass Polymorphismus es Entitäten ermöglicht, verschiedene Formen anzunehmen. Dieses Konzept ist entscheidend für die Erstellung flexibler und wartbarer Software, da es Methoden erlaubt, sich je nach dem Objekt, das sie aufruft, unterschiedlich zu verhalten. Technisch gesehen ermöglicht Polymorphismus die Verwendung einer einzigen Schnittstelle für eine allgemeine Klasse von Aktionen, wobei die spezifische Aktion durch die genaue Art der Situation bestimmt wird. Dies erlaubt es einer Methode, unterschiedliche Aufgaben basierend auf dem Objekt, auf das sie angewendet wird, auszuführen, und bietet somit die Möglichkeit, eine Schnittstelle zu definieren und mehrere Implementierungen zu haben.",
                       "Es gibt zwei Hauptarten von Polymorphismus:",
                       "1. Compile-Time Polymorphismus (statischer Polymorphismus)",
                       "Der Compile-Time Polymorphismus, auch als statischer Polymorphismus bekannt, tritt auf, wenn der Methodenaufruf zur Kompilierzeit aufgelöst wird. Diese Form des Polymorphismus wird durch Methodenüberladung und Operatorüberladung erreicht.",
                       " ° Ad-hoc Polymorphismus",
                       " ° Parametrischer Polymorphismus",
                       "",
                       "2. Run-Time Polymorphismus (dynamischer Polymorphismus)",
                       "",
                       "",
                       "",
                       ""
                    ]
                }
            ]
        },

        {
            "type": "text",
            "content": "Block 04",
            "id": "section6",
            "subContent": [
                {
                    "type": "sub-container",
                    "content": "Themen: Im vierten Block werden wir uns mit den abstrakten Klassen und this. beschäftigen."
                },
                {
                    "_comment": "",
                    "type": "sub-text",
                    "content": "Was macht this? Das Schlüsselwort this ist eine Referenz auf das aktuelle Objekt, in dem der Code ausgeführt wird. In diesem Kontext bedeutet das, dass this eine Referenz auf die aktuelle Instanz der Klasse Kraftfahrzeug ist."
                },
                {
                    "type": "sub-container-code",
                    "_comment": "",
                    "content": [
                        "// Klasse erstellen und Objekte instanziieren",
                        "// Zunächst erstellen wir eine Klasse namens Kraftfahrzeug",
                        "",
                        "public class Kraftfahrzeug {",
                        "    public int ps = 0;",
                        "    private int verbrauch = 0;",
                        "    private int geschwindigkeit = 0;",
                        "}",
                        "",
                        "Kraftfahrzeug fahrzeug1 = new Kraftfahrzeug();",
                        "Kraftfahrzeug fahrzeug2 = new Kraftfahrzeug();",
                        "// Der new-Operator reserviert Speicherplatz für die Objekte fahrzeug1 und fahrzeug2. Wenn wir diese Variablen ausgeben:",
                        "",
                        "System.out.println(fahrzeug1);",
                        "System.out.println(fahrzeug2);",
                        "// Ausgabe",
                        "Kraftfahrzeug@2a139a55",
                        "Kraftfahrzeug@15db9742",
                        "",
                        "Kraftfahrzeug fahrzeug3 = fahrzeug1;",
                        "fahrzeug3.ps = 120;",
                        "fahrzeug1.ps = 160;",
                        "",
                        "System.out.println(fahrzeug3.ps);",
                        "System.out.println(fahrzeug1.ps);",
                        "// Die Ausgabe wird in beiden Fällen 160 sein,  ",
                        "// weil beide Variablen auf dasselbe Objekt verweisen.",
                        "",
                        "// Verwendung des this-Schlüsselwortes",
                        "// Das this-Schlüsselwort liefert eine Referenz auf das aktuelle Objekt. ",
                        "// Es wird häufig in Methoden verwendet, um Namenskonflikte zu lösen oder auf das aktuelle Objekt zuzugreifen.",
                        "",
                        "public class Kraftfahrzeug {",
                        "    private int ps = 0;",
                        "    private int verbrauch = 0;",
                        "    private int geschwindigkeit = 0;",
                        "",
                        "    public Kraftfahrzeug getMe() {",
                        "        return this;",
                        "    }",
                        "}",
                        "System.out.println(fahrzeug1);",
                        "System.out.println(fahrzeug1.getMe());",
                        "// wird dieselbe Speicheradresse ausgegeben."
                    ]
                },
                {
                    "_comment": "",
                    "type": "sub-text",
                    "content": " 1. Auflösen von Namenskonflikten: Dies ist besonders nützlich in Konstruktoren und Setter-Methoden, wenn Parameter und Felder denselben Namen haben."
                },
                {
                    "type": "sub-container-code",
                    "_comment": "",
                    "content": [
                        "public class Kraftfahrzeug {",
                        "    private int geschwindigkeit;",
                        "",
                        "    public void setGeschwindigkeit(int geschwindigkeit) {",
                        "        this.geschwindigkeit = geschwindigkeit;",
                        "    }",
                        "}"
                      ]
                    },
                    {
                        "_comment": "",
                        "type": "sub-text",
                        "content": "2. Java this zum Aufruf von Methoden und Konstruktoren: Das this-Schlüsselwort kann in einem Konstruktor verwendet werden, um einen anderen Konstruktor derselben Klasse aufzurufen. Dies ist nützlich, um Code-Duplikation zu vermeiden und eine zentralisierte Initialisierung zu gewährleisten. Schauen wir uns dies anhand des Beispiels Kraftfahrzeug an."
                    },
                    {
                        "type": "sub-container-code",
                        "_comment": "",
                        "content": [
                            "public class Kraftfahrzeug {",
                            "    private int ps;",
                            "    private int verbrauch;",
                            "    private int geschwindigkeit;",
                            "",
                            "    // Standard-Konstruktor",
                            "    public Kraftfahrzeug() {}",
                            "",
                            "    // Benutzerdefinierter Konstruktor",
                            "    public Kraftfahrzeug(int ps, int verbrauch, int geschwindigkeit) {",
                            "        this.ps = ps;",
                            "        this.verbrauch = verbrauch;",
                            "        this.geschwindigkeit = geschwindigkeit;",
                            "    }",
                            "}"
                        ]
                    },
                    {
                        "_comment": "",
                        "type": "sub-text",
                        "content": "2.1 Aufruf eines Konstruktors von einem anderen Konstruktor aus: Nun erweitern wir den Standard-Konstruktor, um den benutzerdefinierten Konstruktor mit vordefinierten Werten aufzurufen:"
                    },
                    {
                        "type": "sub-container-code",
                        "_comment": "",
                        "content": [
                            "public class Kraftfahrzeug {",
                            "    private int ps;",
                            "    private int verbrauch;",
                            "    private int geschwindigkeit;",
                            "",
                            "    // Standard-Konstruktor",
                            "    public Kraftfahrzeug() {",
                            "        this(80, 6, 240); // Aufruf des benutzerdefinierten Konstruktors",
                            "    }",
                            "",
                            "    // Benutzerdefinierter Konstruktor",
                            "    public Kraftfahrzeug(int ps, int verbrauch, int geschwindigkeit) {",
                            "        this.ps = ps;",
                            "        this.verbrauch = verbrauch;",
                            "        this.geschwindigkeit = geschwindigkeit;",
                            "    }",
                            "}",
                            "// Die Ausgabe dieses Programms wird sein:",
                            "// Fahrzeug 1 - PS: 80, Verbrauch: 6, Geschwindigkeit: 240",
                            "// Fahrzeug 2 - PS: 100, Verbrauch: 8, Geschwindigkeit: 200"
                        ]
                    },
                    {
                        "_comment": "",
                        "type": "sub-text",
                        "content": "Hier ruft der Standard-Konstruktor den benutzerdefinierten Konstruktor mit den Werten 80, 6 und 240 auf. Dies ermöglicht die Initialisierung eines Kraftfahrzeug-Objekts mit diesen Standardwerten, wenn kein Parameter beim Erstellen des Objekts übergeben wird. (Die Anweisung this(80,6,240) sucht in der Klasse nach einem Konsruktor mit drei Parametern und ruft diesen mit den entsprechenden Argumenten auf.)"
                    },          
                    {
                        "_comment": "",
                        "type": "sub-text",
                        "content": "3. Java this als Argument einer Methode:  Dies ist ein häufiger und nützlicher Anwendungsfall, bei dem das aktuelle Objekt an eine Methode übergeben wird, die einen Parameter dieses Objekttyps erwartet."
                    },
                    {
                        "type": "sub-container-code",
                        "_comment": "",
                        "content": [
                            "// Zunächst definieren wir eine Klasse Waschanlage mit einer Methode fahrzeugWaschen, die ein Kraftfahrzeug-Objekt als Parameter erwartet:",
                            "class Waschanlage {",
                            "    public void fahrzeugWaschen(Kraftfahrzeug fahrzeug) {",
                            "        // Implementierungs-Details",
                            "        System.out.println(\"Fahrzeug wird gewaschen: \" + fahrzeug);",
                            "    }",
                            "}"
                          ]
                    },
                    {
                        "type": "sub-container-code",
                        "_comment": "",
                        "content": [
                            "// Nun erweitern wir die Klasse Kraftfahrzeug um eine Methode waschen,",
                            "// die die Methode fahrzeugWaschen aus der Klasse Waschanlage aufruft.",
                            "// Dabei verwenden wir das Schlüsselwort this, um das aktuelle Objekt zu übergeben.",
                            "public class Kraftfahrzeug {",
                            "    private int ps;",
                            "    private int verbrauch;",
                            "    private int geschwindigkeit;",
                            "",
                            "    // Konstruktor",
                            "    public Kraftfahrzeug(int ps, int verbrauch, int geschwindigkeit) {",
                            "        this.ps = ps;",
                            "        this.verbrauch = verbrauch;",
                            "        this.geschwindigkeit = geschwindigkeit;",
                            "    }",
                            "",
                            "    // Methode waschen",
                            "    public void waschen() {",
                            "        Waschanlage waschanlage = new Waschanlage();",
                            "        waschanlage.fahrzeugWaschen(this); // Übergabe des aktuellen Objekts",
                            "    }",
                            "",
                            "    @Override",
                            "    public String toString() {",
                            "        return \"PS: \" + ps + \", Verbrauch: \" + verbrauch + \", Geschwindigkeit: \" + geschwindigkeit;",
                            "    }",
                            "",
                            "    public static void main(String[] args) {",
                            "        Kraftfahrzeug fahrzeug = new Kraftfahrzeug(100, 8, 220);",
                            "        fahrzeug.waschen();",
                            "    }",
                            "}"
                          ]
                    },
                    {
                        "type": "HandlungsZiele",
                        "ziel": "Erklärung",
                        "HandlungsnotwendigeKenntnisse": [
                            "Waschanlage Klasse:",
                            "Die Klasse Waschanlage hat eine Methode fahrzeugWaschen, die ein Kraftfahrzeug-Objekt als Parameter akzeptiert. Diese Methode simuliert das Waschen des Fahrzeugs.",
                            
                            "Kraftfahrzeug Klasse:",
                            "Die Klasse Kraftfahrzeug hat eine Methode waschen, die ein neues Waschanlage-Objekt erstellt und die Methode fahrzeugWaschen aufruft, wobei this als Argument übergeben wird.",
                            
                            "this Schlüsselwort:",
                            "Das Schlüsselwort this verweist auf das aktuelle Objekt der Klasse Kraftfahrzeug, aus dem die Methode waschen aufgerufen wird. Somit wird das aktuelle Kraftfahrzeug-Objekt an die Methode fahrzeugWaschen übergeben.",
                            
                            "main Methode:",
                            "In der main-Methode erstellen wir ein Kraftfahrzeug-Objekt und rufen die Methode waschen auf. Dies führt dazu, dass das aktuelle Kraftfahrzeug-Objekt an die Methode fahrzeugWaschen übergeben wird."
                        ]
                    },
                    {
                        "type": "image",
                        "src": "/imgs/320-img-blokc04-this.png",
                        "alt": "404 img",
                        "id": "section2"
                    },
                    {
                        "_comment": "",
                        "type": "sub-text",
                        "content": "Zusammenfassung      Verwendung von this als Argument:         this wird verwendet, um das aktuelle Objekt als Argument an eine Methode zu übergeben, die einen Parameter dieses Objekttyps erwartet.         Dies ist besonders nützlich, wenn eine Methode einer anderen Klasse aufgerufen wird, die eine Referenz auf das aktuelle Objekt benötigt.     Vorteil:         Die Verwendung von this macht den Code klarer und vermeidet die Notwendigkeit, zusätzliche Referenzen zu erstellen und zu verwalten."
                    },
                    {
                        "type": "image",
                        "src": "/imgs/320-img-block04-oop.jpg",
                        "alt": "404 img",
                        "id": "section2"
                    },
                    {
                        "type": "HandlungsZiele",
                        "ziel": "Abstraktion eine von vier OOP-Säulen",
                        "HandlungsnotwendigeKenntnisse": [
                            "1. Grundprinzip der Abstraktion",
                            "Abstraktion hilft dabei, die reale Welt in der Programmierung zu modellieren, indem es komplexe Systeme vereinfacht und auf ihre grundlegenden Eigenschaften reduziert. Dies geschieht durch: Definieren von abstrakten Klassen und Interfaces, die die allgemeinen Merkmale und Fähigkeiten einer Gruppe von Objekten beschreiben. Verbergen von Implementierungsdetails, die für den Benutzer des Objekts nicht relevant sind.",
                            "2. Abstrakte Klassen",
                            "Eine abstrakte Klasse in Java ist eine Klasse, die nicht instanziiert werden kann. Das bedeutet, dass man kein direktes Objekt einer abstrakten Klasse erstellen kann. Abstrakte Klassen werden verwendet, um eine gemeinsame Basis für andere Klassen zu schaffen, die von ihr erben. Sie können sowohl abstrakte Methoden (Methoden ohne Implementierung) als auch konkrete Methoden (Methoden mit Implementierung) enthalten.",
                            "Eigenschaften einer abstrakten Klasse:",
                            "1. Kann abstrakte und konkrete Methoden enthalten. 2. Kann Konstruktoren, Felder und statische Methoden haben. 3. Kann nicht instanziiert werden. 4. Eine Klasse, die von einer abstrakten Klasse erbt, muss alle abstrakten Methoden implementieren, es sei denn, sie ist selbst abstrakt.",
                            "Abstrakte Methoden: Methoden, die nur deklariert, aber nicht implementiert sind. Diese müssen von den Unterklassen implementiert werden.",
                            "Konkrete Methoden: Methoden, die eine vollständige Implementierung haben.",
                            "Konstruktoren: Eine abstrakte Klasse kann Konstruktoren haben, die von den Unterklassen aufgerufen werden können.",
                            "Felder: Eine abstrakte Klasse kann Felder (Instanzvariablen) definieren, die von Unterklassen geerbt werden können.",
                            "Nicht instanziierbar: Man kann kein Objekt direkt von einer abstrakten Klasse erstellen.",
                            ""
                        ]    
                    },
                    {
                        "type": "sub-container-code",
                        "_comment": "",
                        "content": [
                            "public abstract class Fahrzeug {",
                            "    private int geschwindigkeit;",
                            "    private String name;",
                            "",
                            "    public Fahrzeug(String name) {",
                            "        this.name = name;",
                            "    }",
                            "",
                            "    public void setGeschwindigkeit(int geschwindigkeit) {",
                            "        this.geschwindigkeit = geschwindigkeit;",
                            "    }",
                            "",
                            "    public int getGeschwindigkeit() {",
                            "        return geschwindigkeit;",
                            "    }",
                            "",
                            "    public String getName() {",
                            "        return name;",
                            "    }",
                            "",
                            "    // Abstrakte Methode",
                            "    public abstract void starten();",
                            "",
                            "    // Konkrete Methode",
                            "    public void stoppen() {",
                            "        this.geschwindigkeit = 0;",
                            "        System.out.println(name + \" hat gestoppt.\");",
                            "    }",
                            "}"
                        ]
                    },
                    {
                        "type": "HandlungsZiele",
                        "ziel": "Vorteile und Nachteile abstrakter Klassen",
                        "HandlungsnotwendigeKenntnisse": [
                            "Vorteile:",
                            "Code-Wiederverwendung: Gemeinsamer Code kann in der abstrakten Klasse definiert und von allen Unterklassen wiederverwendet werden.",
                            "Teilweise Implementierung: Man kann einige Methoden in der abstrakten Klasse implementieren und andere abstrakt lassen, um die Unterklassen zu zwingen, spezifische Implementierungen bereitzustellen.",
                            "Vererbung: Abstrakte Klassen unterstützen Vererbung und können Methoden und Felder an Unterklassen vererben.",
                            "Nachteile ",
                            "Keine Mehrfachvererbung: In Java kann eine Klasse nur von einer einzigen abstrakten (oder konkreten) Klasse erben.",
                            "Instanzierung: Man kann keine Objekte von abstrakten Klassen direkt erstellen.",
                            "Fazit",
                            "Verwenden Sie abstrakte Klassen, wenn Sie eine gemeinsame Basis mit einigen standardmässigen Implementierungen schaffen möchten und wenn Klassen, die von dieser Basis erben, eine enge Beziehung haben(ähnliche Eigenschaften oder Verhaltensweisen teilen).",
                            "Verwenden Sie Interfaces, wenn Sie eine Schnittstelle definieren möchten, die von verschiedenen, nicht unbedingt verwandten Klassen implementiert werden soll, und wenn Sie die Flexibilität der Mehrfachvererbung benötigen."
                        ]    
                    },
                    {
                        "type": "sub-container-code",
                        "_comment": "",
                        "content": [
                            "// Abstrakte Basisklasse Fahrzeug",
                            "public abstract class Fahrzeug {",
                            "    private int geschwindigkeit;",
                            "    private String name;",
                            "",
                            "    public Fahrzeug(String name) {",
                            "        this.name = name;",
                            "    }",
                            "",
                            "    public void setGeschwindigkeit(int geschwindigkeit) {",
                            "        this.geschwindigkeit = geschwindigkeit;",
                            "    }",
                            "",
                            "    public int getGeschwindigkeit() {",
                            "        return geschwindigkeit;",
                            "    }",
                            "",
                            "    public String getName() {",
                            "        return name;",
                            "    }",
                            "",
                            "    // Abstrakte Methode",
                            "    public abstract void starten();",
                            "",
                            "    // Konkrete Methode",
                            "    public void stoppen() {",
                            "        this.geschwindigkeit = 0;",
                            "        System.out.println(name + \" hat gestoppt.\");",
                            "    }",
                            "}",
                            "// Konkrete Klasse Auto",
                            "public class Auto extends Fahrzeug {",
                            "    public Auto(String name) {",
                            "        super(name);",
                            "    }",
                            "",
                            "    @Override",
                            "    public void starten() {",
                            "        System.out.println(getName() + \" startet den Motor.\");",
                            "    }",
                            "}",
                            "// Konkrete Klasse Fahrrad",
                            "public class Fahrrad extends Fahrzeug {",
                            "    public Fahrrad(String name) {",
                            "        super(name);",
                            "    }",
                            "",
                            "    @Override",
                            "    public void starten() {",
                            "        System.out.println(getName() + \" beginnt zu treten.\");",
                            "    }",
                            "}",
                            "// Hauptprogramm",
                            "public class Hauptprogramm {",
                            "    public static void main(String[] args) {",
                            "        Fahrzeug auto = new Auto(\"BMW\");",
                            "        Fahrzeug fahrrad = new Fahrrad(\"Mountainbike\");",
                            "",
                            "        auto.starten(); // Ausgabe: BMW startet den Motor.",
                            "        auto.setGeschwindigkeit(100);",
                            "        System.out.println(\"Geschwindigkeit von \" + auto.getName() + \": \" + auto.getGeschwindigkeit() + \" km/h\");",
                            "        auto.stoppen(); // Ausgabe: BMW hat gestoppt.",
                            "",
                            "        fahrrad.starten(); // Ausgabe: Mountainbike beginnt zu treten.",
                            "        fahrrad.setGeschwindigkeit(20);",
                            "        System.out.println(\"Geschwindigkeit von \" + fahrrad.getName() + \": \" + fahrrad.getGeschwindigkeit() + \" km/h\");",
                            "        fahrrad.stoppen(); // Ausgabe: Mountainbike hat gestoppt.",
                            "    }",
                            "}"
                        ]
                    }
            ]
        },

        {
            "type": "text",
            "content": "Block 05",
            "id": "section7",
            "subContent": [
                {
                    "type": "sub-container",
                    "content": "Themen: Im fünften Block wird es eine Einführung zu Methoden und der Klasse String geben, ebenso zu JUnit-Tests und Algorithmen."
                }
               
                
            ]
        },
        {
            "type": "text",
            "content": "Block 06",
            "id": "section8",
            "subContent": [
                {
                    "type": "sub-container",
                    "content": "Themen: Im sechsten Block haben wir gelernt, aus Textaufgaben Klassendiagramme zu erstellen."
                }
                
            ]
        },

        {
            "type": "text",
            "content": "Block 07/08",
            "id": "section9",
            "subContent": [
                {
                    "type": "sub-container",
                    "content": "Themen: Im siebten und achten Block haben wir über Iterationen mittels innerer Klassen gelernt."
                }
               
                
            ]
        },
        {
            "type": "text",
            "content": "Block 09",
            "id": "section10",
            "subContent": [
                {
                    "type": "sub-container",
                    "content": "Themen: Im neunten Block haben wir über die Graphentheorie gelernt."
                }
               
                
            ]
        },
        {
            "type": "sub-layout",
            
            "subContent": [
                {
                    "type": "sub-text",
                    "content": "Vertiefung."
                },
                {
                    "type": "sub-text",
                    "content": "Vertiefung."
                }
            ]
        }
    ]
}
